{"code":"import { __awaiter, __generator, __spreadArray } from \"tslib\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport message from 'antd-message-react';\nimport { uid } from \"uid\";\nimport { indexQuestionDetail, chatWS } from \"./services/index\";\nimport { authToken } from \"./utils/authService\";\nimport Chat from \"./components/chat\";\nimport sendImg from \"./assets/chat-images/send.png\";\nimport './index.less';\nexport default function Home() {\n    var _this = this;\n    var _a = useState([]), chatData = _a[0], setChatData = _a[1];\n    var _b = useState(\"\"), question = _b[0], setQuestion = _b[1];\n    var indexListDOM = useRef(null);\n    // scrollRef是个开关，用于控制是否滚动到最底部，默认开启\n    var scrollRef = useRef(true);\n    // wsRef用于存websocket的send函数\n    var wsRef = useRef(null);\n    // answerRef用于存websocket返回的答案的数组，因为返回顺序可能乱，用index字段进行排序\n    var answerRef = useRef([]);\n    // 用于存questionId，在socket断了之后，用这个id去请求http接口，取问题的答案覆盖到数据队列里\n    var questionIdRef = useRef(\"\");\n    // 用于存websocket的心跳定时器id\n    var timerRef = useRef(null);\n    // 用于存op为status时的返回值\n    var statusRef = useRef({});\n    // 用于存消息发送等待服务端返回的定时器id\n    var waitTimerRef = useRef(null);\n    // 用于存websocket回答过程中的定时器id\n    var answeringTimerRef = useRef(null);\n    // 是否触发了回答中的定时器\n    var answeringTimerIsShow = useRef(false);\n    // question详情接口轮询次数\n    var questionFetchCount = useRef(0);\n    // question详情接口轮询间隔定时器\n    var questionFetchTimerRef = useRef(null);\n    var costomConfig = {\n        waitTimer: 1000 * 5,\n        answeringTimer: 1000 * 3,\n        questionFetchCountMax: 10,\n        socketHeartbeat: 1000 * 30,\n        questionFetchTimer: 1000 * 3 // question详情接口轮询间隔 3s\n    };\n    var domScrollFn = function () {\n        // 滚动到最底部函数\n        if (!scrollRef.current) {\n            // 滚动开关\n            return;\n        }\n        if (indexListDOM.current) {\n            var dom = indexListDOM.current;\n            dom.scrollTop = dom.scrollHeight;\n        }\n    };\n    var handleSetData = function (data, op) {\n        if (op === \"question\") {\n            setChatData(function (cData) {\n                return __spreadArray(__spreadArray([], cData, true), [data], false);\n            });\n            return;\n        }\n        if (op === \"status\") {\n            var id_1 = data.id, isDone_1 = data.isDone, status_1 = data.status;\n            setChatData(function (cData) {\n                return cData.map(function (item) {\n                    if ((item === null || item === void 0 ? void 0 : item.id) === id_1) {\n                        item.isDone = isDone_1;\n                        item.status = status_1;\n                        return item;\n                    }\n                    return item;\n                });\n            });\n            return;\n        }\n        var id = data.id, answer = data.answer, isDone = data.isDone, status = data.status;\n        setChatData(function (cData) {\n            return cData.map(function (item) {\n                if ((item === null || item === void 0 ? void 0 : item.id) === id) {\n                    item.answer = answer;\n                    item.isDone = isDone;\n                    item.status = status;\n                    return item;\n                }\n                return item;\n            });\n        });\n    };\n    var onTextConfirm = function () {\n        if (!question) {\n            message.error('问题不能为空');\n            return;\n        }\n        if (!(question ? question.trim() : \"\")) {\n            message.error('问题不能为空');\n            return;\n        }\n        // 未登录\n        if (!authToken.get()) {\n            message.error('尚未登录');\n            return;\n        }\n        function onSubmit() {\n            // 清空状态值\n            statusRef.current = {};\n            handleWsSend(question ? question.trim() : \"\");\n            setQuestion(\"\");\n        }\n        if (navigator.onLine) {\n            onSubmit();\n        }\n        else {\n            message.error('网络无响应，发送失败');\n        }\n    };\n    function handleWsSend(params) {\n        var _a, _b, _c;\n        if (wsRef.current) {\n            var id = uid();\n            var data = JSON.stringify({\n                op: \"question\",\n                webId: id,\n                token: authToken.get(),\n                question: params,\n            });\n            (_a = wsRef.current) === null || _a === void 0 ? void 0 : _a.send(data);\n            waitTimerRef.current = setTimeout(function () {\n                message.error('服务端未响应，请刷新重试');\n                clearTimeout(waitTimerRef.current);\n            }, costomConfig.waitTimer);\n            answeringTimerIsShow.current = false;\n            // 新建一个问题，此时创建答案为空的数据\n            answerRef.current = [];\n            questionIdRef.current = id;\n            handleSetData({\n                id: id,\n                question: question,\n                answer: \"\",\n                timestamp: +new Date(),\n                isDone: (_b = statusRef.current) === null || _b === void 0 ? void 0 : _b.isDone,\n                status: (_c = statusRef.current) === null || _c === void 0 ? void 0 : _c.status,\n            }, \"question\");\n        }\n    }\n    var answeringTimerCallback = function () {\n        answeringTimerIsShow.current = true;\n        // 如果http返回的answer有值，就切断socket，把http的返回值直接覆盖到对应id的answer字段上\n        message.error('answeringTimerCallback');\n        // 用来处理socket有回复但是回复中断的情况\n        var id = questionIdRef.current;\n        if (!id) {\n            return;\n        }\n        questionFetchCount.current = 0;\n        var onQuestionFetch = function () { return __awaiter(_this, void 0, void 0, function () {\n            var res, answer;\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        questionFetchCount.current = questionFetchCount.current + 1;\n                        return [4 /*yield*/, indexQuestionDetail({ id: id })];\n                    case 1:\n                        res = _b.sent();\n                        if (res.code === 200) {\n                            answer = (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.answer;\n                            if (answer === null || answer === undefined) {\n                                console.log('questionFetchCount.current', questionFetchCount.current);\n                                if (questionFetchCount.current >= costomConfig.questionFetchCountMax) {\n                                    message.error(\"\\u95EE\\u9898\\u8BE6\\u60C5\\u63A5\\u53E3\\u8F6E\\u8BE2\".concat(costomConfig.questionFetchCountMax, \"\\u6B21\\u672A\\u67E5\\u8BE2\\u5230\\u6570\\u636E\"));\n                                    return [2 /*return*/];\n                                }\n                                // 如何answer不存在，轮询indexQuestionDetail接口\n                                clearTimeout(questionFetchTimerRef.current);\n                                questionFetchTimerRef.current = setTimeout(function () {\n                                    onQuestionFetch();\n                                }, costomConfig.questionFetchTimer);\n                                return [2 /*return*/];\n                            }\n                            if (wsRef.current) {\n                                // 关闭socket链接，用http请求回来的答案直接覆盖到对应id上\n                                wsRef.current.close();\n                                console.log(\"🚀 ~ file: index.tsx:184 ~ onQuestionFetch ~ close:\");\n                            }\n                            handleSetData({\n                                id: id,\n                                question: \"\",\n                                answer: answer,\n                                timestamp: 0,\n                            }, \"answer\");\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        onQuestionFetch();\n    };\n    function WsHandshake() {\n        // 连接socket，处理socket返回的message\n        wsRef.current = chatWS({\n            successFn: function (res) {\n                var _a, _b;\n                var op = res.op, webId = res.webId, question = res.question, timestamp = res.timestamp, answer = res.answer, index = res.index, resMessage = res.message, isDone = res.isDone, status = res.status;\n                if (op === \"error\") {\n                    answerRef.current = [];\n                    if (+resMessage === 4201) {\n                        message.info('今日免费次数已用完');\n                        return;\n                    }\n                    //   ws其他报错\n                    message.error(resMessage);\n                    return;\n                }\n                if (op === \"status\") {\n                    // status: 1创建提问未开始回答 2回答中 3回答完成 4回答异常\n                    statusRef.current = {\n                        isDone: isDone,\n                        status: status,\n                    };\n                    if (status === 1) {\n                        // 服务已响应，创建提问未开始回答\n                        clearTimeout(waitTimerRef.current);\n                        return;\n                    }\n                    if (status === 2) {\n                        answeringTimerRef.current = setTimeout(answeringTimerCallback, costomConfig.answeringTimer);\n                        return;\n                    }\n                    if (status === 3 || status === 4) {\n                        if (!answeringTimerIsShow.current) {\n                            clearTimeout(answeringTimerRef.current);\n                        }\n                        statusRef.current = {};\n                        handleSetData({\n                            id: webId,\n                            isDone: isDone,\n                            status: status,\n                            question: \"\",\n                            answer: \"\",\n                            timestamp: 0,\n                        }, \"status\");\n                    }\n                    return;\n                }\n                if (op === \"answer\") {\n                    // ws返回是答案\n                    answerRef.current[index] = answer;\n                    handleSetData({\n                        id: webId,\n                        question: question,\n                        answer: answerRef.current.filter(Boolean).join(\"\"),\n                        timestamp: timestamp,\n                        isDone: (_a = statusRef.current) === null || _a === void 0 ? void 0 : _a.isDone,\n                        status: (_b = statusRef.current) === null || _b === void 0 ? void 0 : _b.status,\n                    }, \"answer\");\n                    // 如果定时器被触发了，就不再执行清除或者重置操作，等待定时器内逻辑执行完\n                    if (!answeringTimerIsShow.current) {\n                        // 每次answer返回时，先清除上一次的answeringTimerRef，然后新建一个answeringTimerRef\n                        clearTimeout(answeringTimerRef.current);\n                        answeringTimerRef.current = setTimeout(answeringTimerCallback, costomConfig.answeringTimer);\n                    }\n                    return;\n                }\n            },\n            errorFn: function (err) {\n            },\n        });\n        wsRef.current.addEventListener(\"open\", function () {\n            clearInterval(timerRef.current);\n            timerRef.current = setInterval(function () {\n                var _a;\n                (_a = wsRef.current) === null || _a === void 0 ? void 0 : _a.send(\"ping\");\n            }, costomConfig.socketHeartbeat);\n        });\n        wsRef.current.addEventListener(\"close\", function (closeEvent) {\n            return onWsCloseOrError(\"close\", closeEvent);\n        });\n        wsRef.current.addEventListener(\"error\", function (errorEvent) {\n            return onWsCloseOrError(\"error\", errorEvent);\n        });\n        return wsRef.current;\n    }\n    var onWsCloseOrError = function (t, e) {\n        // 当websocket状态是 close 或 error 的时候，触发此函数\n        console.log(\"🚀 ~ file: index.tsx:303 ~ onWsCloseOrError ~ onWsCloseOrError:\");\n        wsRef.current && wsRef.current.reconnect();\n    };\n    function onOffline() {\n        message.error('网络已断开，请检查网络状态', 3.5);\n    }\n    var componentDidMount = function () {\n        // 链接websocket\n        WsHandshake();\n        setQuestion(\"\");\n        setChatData([\n            {\n                id: uid(),\n                question: \"Hello\",\n                answer: \"你好，我是人工智能大师，什么问题都能回答，快来和我聊天吧！\",\n                timestamp: 1,\n            },\n        ]);\n        window.addEventListener('offline', onOffline);\n    };\n    var componentWillUnmount = function () {\n        if (timerRef.current) {\n            clearInterval(timerRef.current);\n        }\n        setChatData([]);\n        setQuestion(\"\");\n        window.removeEventListener('offline', onOffline);\n    };\n    useEffect(function () {\n        componentDidMount();\n        return componentWillUnmount;\n    }, []);\n    return (React.createElement(\"div\", { className: \"index\" },\n        React.createElement(\"div\", { className: \"index-list\", ref: indexListDOM }, chatData.map(function (chat, index) {\n            return (React.createElement(Chat, { key: chat.id + index, data: chat, domScrollFn: domScrollFn, onGetScrollSwicth: function () { return scrollRef.current; } }));\n        })),\n        React.createElement(\"div\", { className: \"input-bottom\" },\n            React.createElement(\"div\", { className: \"index-input-box\" },\n                React.createElement(\"input\", { placeholder: \"\\u8BD5\\u8BD5\\u6253\\u5B57\\u548C\\u6211\\u804A\\u5929\\u5427\", className: \"index-input\", value: question, onChange: function (e) {\n                        setQuestion(e.target.value);\n                    }, onKeyDown: function (e) {\n                        if (e.key === \"Enter\") {\n                            onTextConfirm();\n                        }\n                    } }),\n                React.createElement(\"div\", { className: classNames(\"index-input-right\", {\n                        active: !!question.length,\n                    }) },\n                    React.createElement(\"img\", { src: sendImg, className: \"index-send\", onClick: onTextConfirm }))))));\n}\n","references":["/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/@types/react/index.d.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/classnames/index.d.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/antd-message-react/dist/src/message/index.d.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/services/index.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/utils/authService.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/components/chat/index.tsx"],"dts":{"name":"/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/.cache/rollup-plugin-typescript2/placeholder/index.d.ts","writeByteOrderMark":false,"text":"/// <reference types=\"react\" />\nimport './index.less';\nexport interface IItem {\n    id: string;\n    question: string;\n    answer: string;\n    timestamp: number;\n    isDone?: boolean;\n    status?: 1 | 2 | 3 | 4;\n}\nexport default function Home(): JSX.Element;\n"}}
