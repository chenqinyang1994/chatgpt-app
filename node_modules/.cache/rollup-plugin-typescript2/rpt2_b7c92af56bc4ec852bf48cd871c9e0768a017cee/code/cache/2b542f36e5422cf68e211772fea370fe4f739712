{"code":"import { __awaiter, __generator, __spreadArray } from \"tslib\";\nimport React, { useState, useEffect, useRef, useImperativeHandle, forwardRef } from \"react\";\nimport classNames from \"classnames\";\nimport { uid } from \"uid\";\nimport { indexQuestionDetail, chatWS } from \"./services/index\";\nimport { authToken } from \"./utils/authService\";\nimport Chat from \"./components/chat\";\nimport sendImg from \"./assets/chat-images/send.png\";\nimport baseConfig from './base.config';\nimport { INPUT_EMPTY, NOT_LOGIN, NET_OFFLINE, SERVICE_NOT_RESPONDING, QUESTION_FETCH_MAX, INSUFFICIENT_BALANCE, WS_ERROR } from './constants/error';\nimport './index.less';\nvar Home = forwardRef(function (_a, ref) {\n    var className = _a.className, userId = _a.userId, onError = _a.onError, onCopy = _a.onCopy, Question = _a.Question, Answer = _a.Answer;\n    var _b = useState([]), chatData = _b[0], setChatData = _b[1];\n    var _c = useState(\"\"), question = _c[0], setQuestion = _c[1];\n    var indexListDOM = useRef(null);\n    // scrollRef是个开关，用于控制是否滚动到最底部，默认开启\n    var scrollRef = useRef(true);\n    // wsRef用于存websocket的send函数\n    var wsRef = useRef(null);\n    // answerRef用于存websocket返回的答案的数组，因为返回顺序可能乱，用index字段进行排序\n    var answerRef = useRef([]);\n    // 用于存questionId，在socket断了之后，用这个id去请求http接口，取问题的答案覆盖到数据队列里\n    var questionIdRef = useRef(\"\");\n    // 用于存websocket的心跳定时器id\n    var timerRef = useRef(null);\n    // 用于存op为status时的返回值\n    var statusRef = useRef({});\n    // 用于存消息发送等待服务端返回的定时器id\n    var waitTimerRef = useRef(null);\n    // 用于存websocket回答过程中的定时器id\n    var answeringTimerRef = useRef(null);\n    // 是否触发了回答中的定时器\n    var answeringTimerIsShow = useRef(false);\n    // question详情接口轮询次数\n    var questionFetchCount = useRef(0);\n    // question详情接口轮询间隔定时器\n    var questionFetchTimerRef = useRef(null);\n    // 输入框输入的问题\n    var questionInputRef = useRef('');\n    var _d = baseConfig.waitTimer, waitTimer = _d === void 0 ? 5 : _d, // 后端无响应等待时长 默认5s\n    _e = baseConfig.answeringTimer, // 后端无响应等待时长 默认5s\n    answeringTimer = _e === void 0 ? 3 : _e, // websocket message 回复中断等待时长 默认3s\n    _f = baseConfig.questionFetchCountMax, // websocket message 回复中断等待时长 默认3s\n    questionFetchCountMax = _f === void 0 ? 10 : _f, // websocket message 回复中断 用http轮询 最大轮询次数 默认10次\n    _g = baseConfig.socketHeartbeat, // websocket message 回复中断 用http轮询 最大轮询次数 默认10次\n    socketHeartbeat = _g === void 0 ? 30 : _g, // websocket心跳时间间隔 默认30s\n    _h = baseConfig.questionFetchTimer // question详情接口轮询间隔 默认3s\n    , // websocket心跳时间间隔 默认30s\n    questionFetchTimer = _h === void 0 ? 3 : _h // question详情接口轮询间隔 默认3s\n    ;\n    // useImperativeHandle用于定义ref暴露给父组件的方法 获取全部数据\n    useImperativeHandle(ref, function () { return ({\n        getAllData: function () { return chatData; },\n    }); });\n    var domScrollFn = function () {\n        // 滚动到最底部函数\n        if (!scrollRef.current) {\n            // 滚动开关\n            return;\n        }\n        if (indexListDOM.current) {\n            var dom = indexListDOM.current;\n            dom.scrollTop = dom.scrollHeight;\n        }\n    };\n    var handleSetData = function (data, op) {\n        if (op === \"question\") {\n            setChatData(function (cData) {\n                return __spreadArray(__spreadArray([], cData, true), [data], false);\n            });\n            return;\n        }\n        if (op === \"status\") {\n            var id_1 = data.id, isDone_1 = data.isDone, status_1 = data.status;\n            setChatData(function (cData) {\n                return cData.map(function (item) {\n                    if ((item === null || item === void 0 ? void 0 : item.id) === id_1) {\n                        item.isDone = isDone_1;\n                        item.status = status_1;\n                        return item;\n                    }\n                    return item;\n                });\n            });\n            return;\n        }\n        var id = data.id, answer = data.answer, isDone = data.isDone, status = data.status;\n        setChatData(function (cData) {\n            return cData.map(function (item) {\n                if ((item === null || item === void 0 ? void 0 : item.id) === id) {\n                    item.answer = answer;\n                    item.isDone = isDone;\n                    item.status = status;\n                    return item;\n                }\n                return item;\n            });\n        });\n    };\n    var onTextConfirm = function () {\n        if (!(question ? question.trim() : \"\")) {\n            onError(INPUT_EMPTY);\n            return;\n        }\n        // 未登录\n        if (!authToken.get()) {\n            onError(NOT_LOGIN);\n            return;\n        }\n        function onSubmit() {\n            // 清空状态值\n            statusRef.current = {};\n            // 链接websocket\n            WsHandshake();\n        }\n        if (navigator.onLine) {\n            onSubmit();\n        }\n        else {\n            onError(NET_OFFLINE);\n        }\n    };\n    function handleWsSend(params) {\n        var _a, _b, _c;\n        if (wsRef.current) {\n            var id = uid();\n            var wsParamsObject = userId\n                ? {\n                    op: \"question\",\n                    webId: id,\n                    question: params,\n                    userId: userId\n                } : {\n                op: \"question\",\n                webId: id,\n                question: params,\n            };\n            var data = JSON.stringify(wsParamsObject);\n            (_a = wsRef.current) === null || _a === void 0 ? void 0 : _a.send(data);\n            waitTimerRef.current = setTimeout(function () {\n                onError(SERVICE_NOT_RESPONDING);\n                clearTimeout(waitTimerRef.current);\n            }, 1000 * waitTimer);\n            answeringTimerIsShow.current = false;\n            // 新建一个问题，此时创建答案为空的数据\n            answerRef.current = [];\n            questionIdRef.current = id;\n            handleSetData({\n                id: id,\n                question: question,\n                answer: \"\",\n                timestamp: +new Date(),\n                isDone: (_b = statusRef.current) === null || _b === void 0 ? void 0 : _b.isDone,\n                status: (_c = statusRef.current) === null || _c === void 0 ? void 0 : _c.status,\n            }, \"question\");\n        }\n    }\n    var answeringTimerCallback = function () {\n        answeringTimerIsShow.current = true;\n        // 如果http返回的answer有值，就切断socket，把http的返回值直接覆盖到对应id的answer字段上\n        // 用来处理socket有回复但是回复中断的情况\n        var id = questionIdRef.current;\n        if (!id) {\n            return;\n        }\n        questionFetchCount.current = 0;\n        var onQuestionFetch = function () { return __awaiter(void 0, void 0, void 0, function () {\n            var res, answer;\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        questionFetchCount.current = questionFetchCount.current + 1;\n                        return [4 /*yield*/, indexQuestionDetail({ id: id })];\n                    case 1:\n                        res = _b.sent();\n                        if (res.code === 200) {\n                            answer = (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.answer;\n                            if (answer === null || answer === undefined) {\n                                console.log('questionFetchCount.current', questionFetchCount.current);\n                                if (questionFetchCount.current >= questionFetchCountMax) {\n                                    onError(QUESTION_FETCH_MAX);\n                                    return [2 /*return*/];\n                                }\n                                // 如何answer不存在，轮询indexQuestionDetail接口\n                                clearTimeout(questionFetchTimerRef.current);\n                                questionFetchTimerRef.current = setTimeout(function () {\n                                    onQuestionFetch();\n                                }, 1000 * questionFetchTimer);\n                                return [2 /*return*/];\n                            }\n                            if (wsRef.current) {\n                                // 关闭socket链接，用http请求回来的答案直接覆盖到对应id上\n                                wsRef.current.close();\n                                console.log(\"🚀 ~ file: index.tsx:184 ~ onQuestionFetch ~ close:\");\n                            }\n                            handleSetData({\n                                id: id,\n                                question: \"\",\n                                answer: answer,\n                                timestamp: 0,\n                            }, \"answer\");\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        onQuestionFetch();\n    };\n    function WsHandshake() {\n        // 连接socket，处理socket返回的message\n        wsRef.current = chatWS({\n            successFn: function (res) {\n                var _a, _b;\n                var op = res.op, webId = res.webId, question = res.question, timestamp = res.timestamp, answer = res.answer, index = res.index, resMessage = res.message, isDone = res.isDone, status = res.status;\n                if (op === \"error\") {\n                    answerRef.current = [];\n                    if (+resMessage === 4201) {\n                        onError(INSUFFICIENT_BALANCE);\n                        return;\n                    }\n                    //   ws其他报错\n                    onError(WS_ERROR, resMessage);\n                    return;\n                }\n                if (op === \"status\") {\n                    // status: 1创建提问未开始回答 2回答中 3回答完成 4回答异常\n                    statusRef.current = {\n                        isDone: isDone,\n                        status: status,\n                    };\n                    if (status === 1) {\n                        // 服务已响应，创建提问未开始回答\n                        clearTimeout(waitTimerRef.current);\n                        return;\n                    }\n                    if (status === 2) {\n                        answeringTimerRef.current = setTimeout(answeringTimerCallback, 1000 * answeringTimer);\n                        return;\n                    }\n                    if (status === 3 || status === 4) {\n                        if (!answeringTimerIsShow.current) {\n                            clearTimeout(answeringTimerRef.current);\n                        }\n                        wsRef.current && wsRef.current.close();\n                        statusRef.current = {};\n                        handleSetData({\n                            id: webId,\n                            isDone: isDone,\n                            status: status,\n                            question: \"\",\n                            answer: \"\",\n                            timestamp: 0,\n                        }, \"status\");\n                    }\n                    return;\n                }\n                if (op === \"answer\") {\n                    // ws返回是答案\n                    answerRef.current[index] = answer;\n                    handleSetData({\n                        id: webId,\n                        question: question,\n                        answer: answerRef.current.filter(Boolean).join(\"\"),\n                        timestamp: timestamp,\n                        isDone: (_a = statusRef.current) === null || _a === void 0 ? void 0 : _a.isDone,\n                        status: (_b = statusRef.current) === null || _b === void 0 ? void 0 : _b.status,\n                    }, \"answer\");\n                    // 如果定时器被触发了，就不再执行清除或者重置操作，等待定时器内逻辑执行完\n                    if (!answeringTimerIsShow.current) {\n                        // 每次answer返回时，先清除上一次的answeringTimerRef，然后新建一个answeringTimerRef\n                        clearTimeout(answeringTimerRef.current);\n                        answeringTimerRef.current = setTimeout(answeringTimerCallback, 1000 * answeringTimer);\n                    }\n                    return;\n                }\n            },\n            errorFn: function (err) {\n            },\n        });\n        wsRef.current.addEventListener(\"open\", function () {\n            handleWsSend(question ? question.trim() : \"\");\n            setQuestion(\"\");\n            // 开启心跳\n            clearInterval(timerRef.current);\n            timerRef.current = setInterval(function () {\n                var _a;\n                (_a = wsRef.current) === null || _a === void 0 ? void 0 : _a.send(\"ping\");\n            }, 1000 * socketHeartbeat);\n        });\n        wsRef.current.addEventListener(\"close\", function (closeEvent) {\n            return onWsCloseOrError(\"close\", closeEvent);\n        });\n        wsRef.current.addEventListener(\"error\", function (errorEvent) {\n            return onWsCloseOrError(\"error\", errorEvent);\n        });\n        return wsRef.current;\n    }\n    var onWsCloseOrError = function (t, e) {\n        // 当websocket状态是 close 或 error 的时候，取消心跳\n        clearInterval(timerRef.current);\n    };\n    function onOffline() {\n        onError(NET_OFFLINE);\n    }\n    var componentDidMount = function () {\n        setQuestion(\"\");\n        setChatData([\n            {\n                id: uid(),\n                question: \"Hello\",\n                answer: \"你好，我是人工智能大师，什么问题都能回答，快来和我聊天吧！\",\n                timestamp: 1,\n            },\n        ]);\n        window.addEventListener('offline', onOffline);\n    };\n    var componentWillUnmount = function () {\n        if (timerRef.current) {\n            clearInterval(timerRef.current);\n        }\n        setChatData([]);\n        setQuestion(\"\");\n        window.removeEventListener('offline', onOffline);\n    };\n    useEffect(function () {\n        componentDidMount();\n        return componentWillUnmount;\n    }, []);\n    return (React.createElement(\"div\", { className: classNames([\"index\", className]) },\n        React.createElement(\"div\", { className: \"index-list\", ref: indexListDOM }, chatData.map(function (chat, index) {\n            return (React.createElement(Chat, { key: chat.id + index, data: chat, onCopy: onCopy, domScrollFn: domScrollFn, onGetScrollSwicth: function () { return scrollRef.current; }, Question: Question, Answer: Answer }));\n        })),\n        React.createElement(\"div\", { className: \"input-bottom\" },\n            React.createElement(\"div\", { className: \"index-input-box\" },\n                React.createElement(\"input\", { placeholder: \"\\u8BD5\\u8BD5\\u6253\\u5B57\\u548C\\u6211\\u804A\\u5929\\u5427\", className: \"index-input\", value: question, onChange: function (e) {\n                        setQuestion(e.target.value);\n                    }, onKeyDown: function (e) {\n                        if (e.key === \"Enter\") {\n                            questionInputRef.current = question;\n                            onTextConfirm();\n                        }\n                    } }),\n                React.createElement(\"div\", { className: classNames(\"index-input-right\", {\n                        active: !!question.length,\n                    }) },\n                    React.createElement(\"img\", { src: sendImg, className: \"index-send\", onClick: onTextConfirm }))))));\n});\nexport default Home;\n","references":["/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/@types/react/index.d.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/classnames/index.d.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/uid/index.d.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/services/index.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/utils/authService.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/components/chat/index.tsx","/Users/chenqinyang/Desktop/chat-requset-rollup/src/base.config.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/constants/error.ts"],"dts":{"name":"/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/.cache/rollup-plugin-typescript2/placeholder/index.d.ts","writeByteOrderMark":false,"text":"import React from \"react\";\nimport './index.less';\nexport interface AnswerProps {\n    data: string;\n    isDone?: boolean;\n    status?: 1 | 2 | 3 | 4;\n}\nexport interface HomeProps {\n    className?: string;\n    userId?: string;\n    onError: (errorType: string, msg?: string) => void;\n    onCopy?: (type: 'question' | 'answer') => void;\n    Question?: ({ data }: {\n        data: string;\n    }) => JSX.Element;\n    Answer?: ({ data, isDone, status }: AnswerProps) => JSX.Element;\n}\nexport interface InnerComponentRef {\n    getAllData: () => any[];\n}\nexport interface IItem {\n    id: string;\n    question: string;\n    answer: string;\n    timestamp: number;\n    isDone?: boolean;\n    status?: 1 | 2 | 3 | 4;\n}\ndeclare const Home: React.ForwardRefExoticComponent<HomeProps & React.RefAttributes<InnerComponentRef>>;\nexport default Home;\n"}}
