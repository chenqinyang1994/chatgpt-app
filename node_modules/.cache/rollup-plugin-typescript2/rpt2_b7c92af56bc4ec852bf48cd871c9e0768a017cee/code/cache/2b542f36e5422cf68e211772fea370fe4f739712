{"code":"import { __awaiter, __generator, __spreadArray } from \"tslib\";\nimport React, { useState, useEffect, useRef, useImperativeHandle, forwardRef } from \"react\";\nimport classNames from \"classnames\";\nimport { uid } from \"uid\";\nimport { indexQuestionDetail, chatWS } from \"./services/index\";\nimport { authToken } from \"./utils/authService\";\nimport Chat from \"./components/chat\";\nimport sendImg from \"./assets/chat-images/send.png\";\nimport baseConfig from './base.config';\nimport { INPUT_EMPTY, NOT_LOGIN, NET_OFFLINE, SERVICE_NOT_RESPONDING, QUESTION_FETCH_MAX, INSUFFICIENT_BALANCE, WS_ERROR } from './constants/error';\nimport './index.less';\nvar Home = forwardRef(function (_a, ref) {\n    var className = _a.className, userId = _a.userId, onError = _a.onError, onCopy = _a.onCopy, Question = _a.Question, Answer = _a.Answer;\n    var _b = useState([]), chatData = _b[0], setChatData = _b[1];\n    var _c = useState(\"\"), question = _c[0], setQuestion = _c[1];\n    var indexListDOM = useRef(null);\n    // scrollRefæ˜¯ä¸ªå¼€å…³ï¼Œç”¨äºŽæŽ§åˆ¶æ˜¯å¦æ»šåŠ¨åˆ°æœ€åº•éƒ¨ï¼Œé»˜è®¤å¼€å¯\n    var scrollRef = useRef(true);\n    // wsRefç”¨äºŽå­˜websocketçš„sendå‡½æ•°\n    var wsRef = useRef(null);\n    // answerRefç”¨äºŽå­˜websocketè¿”å›žçš„ç­”æ¡ˆçš„æ•°ç»„ï¼Œå› ä¸ºè¿”å›žé¡ºåºå¯èƒ½ä¹±ï¼Œç”¨indexå­—æ®µè¿›è¡ŒæŽ’åº\n    var answerRef = useRef([]);\n    // ç”¨äºŽå­˜questionIdï¼Œåœ¨socketæ–­äº†ä¹‹åŽï¼Œç”¨è¿™ä¸ªidåŽ»è¯·æ±‚httpæŽ¥å£ï¼Œå–é—®é¢˜çš„ç­”æ¡ˆè¦†ç›–åˆ°æ•°æ®é˜Ÿåˆ—é‡Œ\n    var questionIdRef = useRef(\"\");\n    // ç”¨äºŽå­˜websocketçš„å¿ƒè·³å®šæ—¶å™¨id\n    var timerRef = useRef(null);\n    // ç”¨äºŽå­˜opä¸ºstatusæ—¶çš„è¿”å›žå€¼\n    var statusRef = useRef({});\n    // ç”¨äºŽå­˜æ¶ˆæ¯å‘é€ç­‰å¾…æœåŠ¡ç«¯è¿”å›žçš„å®šæ—¶å™¨id\n    var waitTimerRef = useRef(null);\n    // ç”¨äºŽå­˜websocketå›žç­”è¿‡ç¨‹ä¸­çš„å®šæ—¶å™¨id\n    var answeringTimerRef = useRef(null);\n    // æ˜¯å¦è§¦å‘äº†å›žç­”ä¸­çš„å®šæ—¶å™¨\n    var answeringTimerIsShow = useRef(false);\n    // questionè¯¦æƒ…æŽ¥å£è½®è¯¢æ¬¡æ•°\n    var questionFetchCount = useRef(0);\n    // questionè¯¦æƒ…æŽ¥å£è½®è¯¢é—´éš”å®šæ—¶å™¨\n    var questionFetchTimerRef = useRef(null);\n    // è¾“å…¥æ¡†è¾“å…¥çš„é—®é¢˜\n    var questionInputRef = useRef('');\n    var _d = baseConfig.waitTimer, waitTimer = _d === void 0 ? 5 : _d, // åŽç«¯æ— å“åº”ç­‰å¾…æ—¶é•¿ é»˜è®¤5s\n    _e = baseConfig.answeringTimer, // åŽç«¯æ— å“åº”ç­‰å¾…æ—¶é•¿ é»˜è®¤5s\n    answeringTimer = _e === void 0 ? 3 : _e, // websocket message å›žå¤ä¸­æ–­ç­‰å¾…æ—¶é•¿ é»˜è®¤3s\n    _f = baseConfig.questionFetchCountMax, // websocket message å›žå¤ä¸­æ–­ç­‰å¾…æ—¶é•¿ é»˜è®¤3s\n    questionFetchCountMax = _f === void 0 ? 10 : _f, // websocket message å›žå¤ä¸­æ–­ ç”¨httpè½®è¯¢ æœ€å¤§è½®è¯¢æ¬¡æ•° é»˜è®¤10æ¬¡\n    _g = baseConfig.socketHeartbeat, // websocket message å›žå¤ä¸­æ–­ ç”¨httpè½®è¯¢ æœ€å¤§è½®è¯¢æ¬¡æ•° é»˜è®¤10æ¬¡\n    socketHeartbeat = _g === void 0 ? 30 : _g, // websocketå¿ƒè·³æ—¶é—´é—´éš” é»˜è®¤30s\n    _h = baseConfig.questionFetchTimer // questionè¯¦æƒ…æŽ¥å£è½®è¯¢é—´éš” é»˜è®¤3s\n    , // websocketå¿ƒè·³æ—¶é—´é—´éš” é»˜è®¤30s\n    questionFetchTimer = _h === void 0 ? 3 : _h // questionè¯¦æƒ…æŽ¥å£è½®è¯¢é—´éš” é»˜è®¤3s\n    ;\n    // useImperativeHandleç”¨äºŽå®šä¹‰refæš´éœ²ç»™çˆ¶ç»„ä»¶çš„æ–¹æ³• èŽ·å–å…¨éƒ¨æ•°æ®\n    useImperativeHandle(ref, function () { return ({\n        getAllData: function () { return chatData; },\n    }); });\n    var domScrollFn = function () {\n        // æ»šåŠ¨åˆ°æœ€åº•éƒ¨å‡½æ•°\n        if (!scrollRef.current) {\n            // æ»šåŠ¨å¼€å…³\n            return;\n        }\n        if (indexListDOM.current) {\n            var dom = indexListDOM.current;\n            dom.scrollTop = dom.scrollHeight;\n        }\n    };\n    var handleSetData = function (data, op) {\n        if (op === \"question\") {\n            setChatData(function (cData) {\n                return __spreadArray(__spreadArray([], cData, true), [data], false);\n            });\n            return;\n        }\n        if (op === \"status\") {\n            var id_1 = data.id, isDone_1 = data.isDone, status_1 = data.status;\n            setChatData(function (cData) {\n                return cData.map(function (item) {\n                    if ((item === null || item === void 0 ? void 0 : item.id) === id_1) {\n                        item.isDone = isDone_1;\n                        item.status = status_1;\n                        return item;\n                    }\n                    return item;\n                });\n            });\n            return;\n        }\n        var id = data.id, answer = data.answer, isDone = data.isDone, status = data.status;\n        setChatData(function (cData) {\n            return cData.map(function (item) {\n                if ((item === null || item === void 0 ? void 0 : item.id) === id) {\n                    item.answer = answer;\n                    item.isDone = isDone;\n                    item.status = status;\n                    return item;\n                }\n                return item;\n            });\n        });\n    };\n    var onTextConfirm = function () {\n        if (!(question ? question.trim() : \"\")) {\n            onError(INPUT_EMPTY);\n            return;\n        }\n        // æœªç™»å½•\n        if (!authToken.get()) {\n            onError(NOT_LOGIN);\n            return;\n        }\n        function onSubmit() {\n            // æ¸…ç©ºçŠ¶æ€å€¼\n            statusRef.current = {};\n            // é“¾æŽ¥websocket\n            WsHandshake();\n        }\n        if (navigator.onLine) {\n            onSubmit();\n        }\n        else {\n            onError(NET_OFFLINE);\n        }\n    };\n    function handleWsSend(params) {\n        var _a, _b, _c;\n        if (wsRef.current) {\n            var id = uid();\n            var wsParamsObject = userId\n                ? {\n                    op: \"question\",\n                    webId: id,\n                    question: params,\n                    userId: userId\n                } : {\n                op: \"question\",\n                webId: id,\n                question: params,\n            };\n            var data = JSON.stringify(wsParamsObject);\n            (_a = wsRef.current) === null || _a === void 0 ? void 0 : _a.send(data);\n            waitTimerRef.current = setTimeout(function () {\n                onError(SERVICE_NOT_RESPONDING);\n                clearTimeout(waitTimerRef.current);\n            }, 1000 * waitTimer);\n            answeringTimerIsShow.current = false;\n            // æ–°å»ºä¸€ä¸ªé—®é¢˜ï¼Œæ­¤æ—¶åˆ›å»ºç­”æ¡ˆä¸ºç©ºçš„æ•°æ®\n            answerRef.current = [];\n            questionIdRef.current = id;\n            handleSetData({\n                id: id,\n                question: question,\n                answer: \"\",\n                timestamp: +new Date(),\n                isDone: (_b = statusRef.current) === null || _b === void 0 ? void 0 : _b.isDone,\n                status: (_c = statusRef.current) === null || _c === void 0 ? void 0 : _c.status,\n            }, \"question\");\n        }\n    }\n    var answeringTimerCallback = function () {\n        answeringTimerIsShow.current = true;\n        // å¦‚æžœhttpè¿”å›žçš„answeræœ‰å€¼ï¼Œå°±åˆ‡æ–­socketï¼ŒæŠŠhttpçš„è¿”å›žå€¼ç›´æŽ¥è¦†ç›–åˆ°å¯¹åº”idçš„answerå­—æ®µä¸Š\n        // ç”¨æ¥å¤„ç†socketæœ‰å›žå¤ä½†æ˜¯å›žå¤ä¸­æ–­çš„æƒ…å†µ\n        var id = questionIdRef.current;\n        if (!id) {\n            return;\n        }\n        questionFetchCount.current = 0;\n        var onQuestionFetch = function () { return __awaiter(void 0, void 0, void 0, function () {\n            var res, answer;\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        questionFetchCount.current = questionFetchCount.current + 1;\n                        return [4 /*yield*/, indexQuestionDetail({ id: id })];\n                    case 1:\n                        res = _b.sent();\n                        if (res.code === 200) {\n                            answer = (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.answer;\n                            if (answer === null || answer === undefined) {\n                                console.log('questionFetchCount.current', questionFetchCount.current);\n                                if (questionFetchCount.current >= questionFetchCountMax) {\n                                    onError(QUESTION_FETCH_MAX);\n                                    return [2 /*return*/];\n                                }\n                                // å¦‚ä½•answerä¸å­˜åœ¨ï¼Œè½®è¯¢indexQuestionDetailæŽ¥å£\n                                clearTimeout(questionFetchTimerRef.current);\n                                questionFetchTimerRef.current = setTimeout(function () {\n                                    onQuestionFetch();\n                                }, 1000 * questionFetchTimer);\n                                return [2 /*return*/];\n                            }\n                            if (wsRef.current) {\n                                // å…³é—­socketé“¾æŽ¥ï¼Œç”¨httpè¯·æ±‚å›žæ¥çš„ç­”æ¡ˆç›´æŽ¥è¦†ç›–åˆ°å¯¹åº”idä¸Š\n                                wsRef.current.close();\n                                console.log(\"ðŸš€ ~ file: index.tsx:184 ~ onQuestionFetch ~ close:\");\n                            }\n                            handleSetData({\n                                id: id,\n                                question: \"\",\n                                answer: answer,\n                                timestamp: 0,\n                            }, \"answer\");\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        onQuestionFetch();\n    };\n    function WsHandshake() {\n        // è¿žæŽ¥socketï¼Œå¤„ç†socketè¿”å›žçš„message\n        wsRef.current = chatWS({\n            successFn: function (res) {\n                var _a, _b;\n                var op = res.op, webId = res.webId, question = res.question, timestamp = res.timestamp, answer = res.answer, index = res.index, resMessage = res.message, isDone = res.isDone, status = res.status;\n                if (op === \"error\") {\n                    answerRef.current = [];\n                    if (+resMessage === 4201) {\n                        onError(INSUFFICIENT_BALANCE);\n                        return;\n                    }\n                    //   wså…¶ä»–æŠ¥é”™\n                    onError(WS_ERROR, resMessage);\n                    return;\n                }\n                if (op === \"status\") {\n                    // status: 1åˆ›å»ºæé—®æœªå¼€å§‹å›žç­” 2å›žç­”ä¸­ 3å›žç­”å®Œæˆ 4å›žç­”å¼‚å¸¸\n                    statusRef.current = {\n                        isDone: isDone,\n                        status: status,\n                    };\n                    if (status === 1) {\n                        // æœåŠ¡å·²å“åº”ï¼Œåˆ›å»ºæé—®æœªå¼€å§‹å›žç­”\n                        clearTimeout(waitTimerRef.current);\n                        return;\n                    }\n                    if (status === 2) {\n                        answeringTimerRef.current = setTimeout(answeringTimerCallback, 1000 * answeringTimer);\n                        return;\n                    }\n                    if (status === 3 || status === 4) {\n                        if (!answeringTimerIsShow.current) {\n                            clearTimeout(answeringTimerRef.current);\n                        }\n                        wsRef.current && wsRef.current.close();\n                        statusRef.current = {};\n                        handleSetData({\n                            id: webId,\n                            isDone: isDone,\n                            status: status,\n                            question: \"\",\n                            answer: \"\",\n                            timestamp: 0,\n                        }, \"status\");\n                    }\n                    return;\n                }\n                if (op === \"answer\") {\n                    // wsè¿”å›žæ˜¯ç­”æ¡ˆ\n                    answerRef.current[index] = answer;\n                    handleSetData({\n                        id: webId,\n                        question: question,\n                        answer: answerRef.current.filter(Boolean).join(\"\"),\n                        timestamp: timestamp,\n                        isDone: (_a = statusRef.current) === null || _a === void 0 ? void 0 : _a.isDone,\n                        status: (_b = statusRef.current) === null || _b === void 0 ? void 0 : _b.status,\n                    }, \"answer\");\n                    // å¦‚æžœå®šæ—¶å™¨è¢«è§¦å‘äº†ï¼Œå°±ä¸å†æ‰§è¡Œæ¸…é™¤æˆ–è€…é‡ç½®æ“ä½œï¼Œç­‰å¾…å®šæ—¶å™¨å†…é€»è¾‘æ‰§è¡Œå®Œ\n                    if (!answeringTimerIsShow.current) {\n                        // æ¯æ¬¡answerè¿”å›žæ—¶ï¼Œå…ˆæ¸…é™¤ä¸Šä¸€æ¬¡çš„answeringTimerRefï¼Œç„¶åŽæ–°å»ºä¸€ä¸ªansweringTimerRef\n                        clearTimeout(answeringTimerRef.current);\n                        answeringTimerRef.current = setTimeout(answeringTimerCallback, 1000 * answeringTimer);\n                    }\n                    return;\n                }\n            },\n            errorFn: function (err) {\n            },\n        });\n        wsRef.current.addEventListener(\"open\", function () {\n            handleWsSend(question ? question.trim() : \"\");\n            setQuestion(\"\");\n            // å¼€å¯å¿ƒè·³\n            clearInterval(timerRef.current);\n            timerRef.current = setInterval(function () {\n                var _a;\n                (_a = wsRef.current) === null || _a === void 0 ? void 0 : _a.send(\"ping\");\n            }, 1000 * socketHeartbeat);\n        });\n        wsRef.current.addEventListener(\"close\", function (closeEvent) {\n            return onWsCloseOrError(\"close\", closeEvent);\n        });\n        wsRef.current.addEventListener(\"error\", function (errorEvent) {\n            return onWsCloseOrError(\"error\", errorEvent);\n        });\n        return wsRef.current;\n    }\n    var onWsCloseOrError = function (t, e) {\n        // å½“websocketçŠ¶æ€æ˜¯ close æˆ– error çš„æ—¶å€™ï¼Œå–æ¶ˆå¿ƒè·³\n        clearInterval(timerRef.current);\n    };\n    function onOffline() {\n        onError(NET_OFFLINE);\n    }\n    var componentDidMount = function () {\n        setQuestion(\"\");\n        setChatData([\n            {\n                id: uid(),\n                question: \"Hello\",\n                answer: \"ä½ å¥½ï¼Œæˆ‘æ˜¯äººå·¥æ™ºèƒ½å¤§å¸ˆï¼Œä»€ä¹ˆé—®é¢˜éƒ½èƒ½å›žç­”ï¼Œå¿«æ¥å’Œæˆ‘èŠå¤©å§ï¼\",\n                timestamp: 1,\n            },\n        ]);\n        window.addEventListener('offline', onOffline);\n    };\n    var componentWillUnmount = function () {\n        if (timerRef.current) {\n            clearInterval(timerRef.current);\n        }\n        setChatData([]);\n        setQuestion(\"\");\n        window.removeEventListener('offline', onOffline);\n    };\n    useEffect(function () {\n        componentDidMount();\n        return componentWillUnmount;\n    }, []);\n    return (React.createElement(\"div\", { className: classNames([\"index\", className]) },\n        React.createElement(\"div\", { className: \"index-list\", ref: indexListDOM }, chatData.map(function (chat, index) {\n            return (React.createElement(Chat, { key: chat.id + index, data: chat, onCopy: onCopy, domScrollFn: domScrollFn, onGetScrollSwicth: function () { return scrollRef.current; }, Question: Question, Answer: Answer }));\n        })),\n        React.createElement(\"div\", { className: \"input-bottom\" },\n            React.createElement(\"div\", { className: \"index-input-box\" },\n                React.createElement(\"input\", { placeholder: \"\\u8BD5\\u8BD5\\u6253\\u5B57\\u548C\\u6211\\u804A\\u5929\\u5427\", className: \"index-input\", value: question, onChange: function (e) {\n                        setQuestion(e.target.value);\n                    }, onKeyDown: function (e) {\n                        if (e.key === \"Enter\") {\n                            questionInputRef.current = question;\n                            onTextConfirm();\n                        }\n                    } }),\n                React.createElement(\"div\", { className: classNames(\"index-input-right\", {\n                        active: !!question.length,\n                    }) },\n                    React.createElement(\"img\", { src: sendImg, className: \"index-send\", onClick: onTextConfirm }))))));\n});\nexport default Home;\n","references":["/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/@types/react/index.d.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/classnames/index.d.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/uid/index.d.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/services/index.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/utils/authService.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/components/chat/index.tsx","/Users/chenqinyang/Desktop/chat-requset-rollup/src/base.config.ts","/Users/chenqinyang/Desktop/chat-requset-rollup/src/constants/error.ts"],"dts":{"name":"/Users/chenqinyang/Desktop/chat-requset-rollup/node_modules/.cache/rollup-plugin-typescript2/placeholder/index.d.ts","writeByteOrderMark":false,"text":"import React from \"react\";\nimport './index.less';\nexport interface AnswerProps {\n    data: string;\n    isDone?: boolean;\n    status?: 1 | 2 | 3 | 4;\n}\nexport interface HomeProps {\n    className?: string;\n    userId?: string;\n    onError: (errorType: string, msg?: string) => void;\n    onCopy?: (type: 'question' | 'answer') => void;\n    Question?: ({ data }: {\n        data: string;\n    }) => JSX.Element;\n    Answer?: ({ data, isDone, status }: AnswerProps) => JSX.Element;\n}\nexport interface InnerComponentRef {\n    getAllData: () => any[];\n}\nexport interface IItem {\n    id: string;\n    question: string;\n    answer: string;\n    timestamp: number;\n    isDone?: boolean;\n    status?: 1 | 2 | 3 | 4;\n}\ndeclare const Home: React.ForwardRefExoticComponent<HomeProps & React.RefAttributes<InnerComponentRef>>;\nexport default Home;\n"}}
